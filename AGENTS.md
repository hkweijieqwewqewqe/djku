AGENTS 架构指南
本项目采用 Flutter 构建跨平台（macOS、Windows、iOS、Android）的单 Deck 播放器界面，后端使用 JUCE 负责音频处理（文件加载、播放控制、频谱分析、节拍检测、波形预处理等）。为清晰分工，我们设计多个“代理（Agent）”模块，每个代理独立负责特定任务，相互协作构成完整音频播放与可视化系统。
代理分工与职责
代理角色	主要职责	输入	输出	调用方式/生命周期
音频文件管理代理 (File Manager)	加载音频文件、管理曲目列表、读取元数据（时长、码率、采样率等），并准备音频流源。	用户文件路径或 URL	JUCE 音频读取器 (AudioFormatReader/AudioFormatReaderSource)、元信息	由 Flutter-JUCE 桥接调用。长期存在，处理每次新曲目加载；可缓存已读文件以加速重复访问。
波形分析代理 (Waveform Agent)	生成曲目的波形数据供可视化使用（包括缩略图和高分辨率细节）。支持RGB 频段着色（红-低频、绿-中频、蓝-高频）、高分辨率缩放和平滑滚动。	音频文件或音频采样流	波形幅度数组或图像数据，支持不同分辨率的波形视图	在文件加载后异步启动，使用 JUCE AudioThumbnail 等工具扫描音频生成缩略波形
docs.juce.com
。可在用户调整缩放时进一步计算细节。分析完成后通知渲染代理或 UI 更新。
节拍检测代理 (Beat Detection Agent)	分析音频信号计算 BPM、节拍位置和下拍（downbeat），生成节拍网格数据以供同步指示。	音频文件或音频样本数据	BPM 值、节拍时间戳列表、拍号网格	在曲目加载时或后台通过异步任务进行，可使用常见的频谱峰值检测算法。可先快速预分析（如只用前1分钟）以快速获取初步 BPM
manual.mixxx.org
；完整分析后更新节拍网格。结果可缓存，下次直接使用。
频谱分析代理 (Spectrum Agent)	实时计算音频的频谱（FFT），用于频谱显示或辅助分析（如可视化谱图或判断音色变化）。	实时音频缓冲（播放时）	实时频谱幅度数据数组	在音频播放过程中持续运行，每次音频回调时更新频谱数据，供可视化界面实时使用。此代理与播放代理紧耦合，可看作播放流程的一部分。
图像渲染协调代理 (Rendering Agent)	将波形数据、节拍信息和播放进度组合为可视图像或 UI 更新指令，负责波形滚动、光标定位、节拍标记等绘制逻辑。	波形数据、节拍网格、当前播放位置	波形图像帧（可传输给 Flutter），或绘制指令与状态	响应波形分析和节拍检测完成事件，以及播放进度更新。通常在 GUI 主线程或 OpenGL 线程执行，生成渲染结果供 Flutter 显示。
播放控制代理 (Playback Agent)	控制音频播放、暂停、快进/快退、调整速率/音调等。维护播放头位置并向其他代理广播当前时间。	控制命令（播放/暂停/跳转等）	音频输出流、当前播放时间	由 Flutter-JUCE 桥接代理或 UI 调用，调用 JUCE 音频设备接口启动/停止声音输出。周期性地向状态同步系统报告播放时间和位置。
Flutter–JUCE 桥接代理 (Bridge Agent)	负责 Flutter UI 与 JUCE 后端的双向通信，包括注册 Dart 平台通道（Platform Channels）或 FFI 接口，接收 UI 指令并分发给相应代理，同时将后端状态或数据反馈给 Flutter。	Flutter 层发来的消息（如加载文件、控制命令）	调用其他代理并收集响应，将结果或事件通过消息通道返回给 Flutter	作为应用启动时初始化的单例模块。监听 Flutter 侧事件（通过 MethodChannel 或 FFI），并封装成后台命令；同时接收来自其他代理的异步事件（如分析完成、播放位置更新），推送给 Flutter 更新界面。
状态同步代理 (State Agent，可选)	管理全局状态，如当前活动曲目、播放状态、各代理的执行状态等，并负责分发状态变更事件。	各代理状态和外部命令	统一的系统状态、广播事件	可作为一个轻量级总线或观察者模式实现，持续运行。各代理上报自身状态变更，由其触发全局更新（确保 UI 与后端状态一致）。

音频文件管理代理
职责：响应用户请求打开曲目，调用 JUCE 的 AudioFormatManager 和对应 AudioFormatReader 加载各种音频格式
docs.juce.com
docs.juce.com
（如 WAV、AIFF、FLAC、OGG、MP3，以及 macOS/iOS 下的 AAC/ALAC 等）。提取并缓存文件时长、采样率、声道数等元信息，以供其它代理使用。
调用方式：由 Flutter UI 通过桥接代理发起（例如发来加载文件的命令）。可考虑在扫描播放列表时后台预载入或分析文件。
输入：音频文件路径/URL。
输出：JUCE 音频数据源或读取器对象、元数据结构。
注意：对于高效的多格式支持，JUCE 已内置多种 AudioFormat（如 WavAudioFormat、AiffAudioFormat、FlacAudioFormat、OggVorbisAudioFormat、MP3AudioFormat 等
docs.juce.com
docs.juce.com
）。在 macOS/iOS 环境下可利用 CoreAudioFormat 调用系统 AudioToolbox，解码平台支持的格式（如 AAC、ALAC）
docs.juce.com
。应处理加载错误并向 UI 报错。文件管理代理通常在应用生命周期内常驻，可以对已加载文件做缓存，避免反复扫描。
波形分析代理
职责：从音频数据中生成可视化波形。包括两部分：一是生成低分辨率的全曲目波形概览（overview），二是支持细节缩放的高分辨率数据。波形应支持 RGB 频段着色（红：低频、绿：中频、蓝：高频），以及平滑滚动显示和节拍对齐指示。
调用方式：通常在文件加载后异步启动分析。例如使用 JUCE 的 AudioThumbnail 类来扫描音频生成波形数据
docs.juce.com
。当用户放大波形时，可能需要进一步计算细节或直接读取原始样本。分析完成后，通知渲染代理更新 UI。
输入：音频文件或读取到的 PCM 采样数据。
输出：多分辨率的波形数据结构（如不同比例的幅度数组），可直接用于绘图。也可输出用于显示的图像缓存。
实现建议：借助 AudioThumbnail 可方便地异步生成缩略波形，并利用其缓存机制避免重复计算
docs.juce.com
。对于 RGB 着色，可对音频进行带通滤波（低/中/高三段），取各段能量值并映射到对应颜色通道，实现类似 Mixxx 的 RGB 波形
mixxx.org
。高分辨率缩放可直接使用原始样本或在关键区域重采样。为保证高性能滚动，建议采用 GPU 加速（如 OpenGL/Metal/GLSL 着色器），参考 Mixxx 2.4 版本的性能优化
mixxx.org
mixxx.org
。
示例：Mixxx 2.4 中的 GLSL 加速 RGB 波形（红色表示低频，蓝色表示高频）
mixxx.org
。 波形代理应以类似方式将不同频带能量可视化，同时保持 60fps 平滑滚动
mixxx.org
，支持任意放大级别（甚至采样级别）查看细节。
节拍检测代理
职责：分析曲目节奏，输出 BPM（拍速）和每个节拍时间点，确定第一拍（重拍）等信息，用于同步视觉或混音。
调用方式：在文件加载后立即异步执行预分析，也可在后台批量分析曲库。用户也可手动触发重新分析。类似 Mixxx 的实现，默认对整曲分析，提供“快速分析”选项只扫描前1分钟
manual.mixxx.org
。分析完成后将结果传递给渲染代理和 UI（如绘制节拍线）。
输入：音频文件数据或 PCM 样本。
输出：BPM 值、节拍网格（节拍时间戳列表、每小节下拍位置等）。
预期行为：检测算法可基于谱图差分或峰值检测，要求足够精确（Mixxx 称其为“超精确”节拍检测
manual.mixxx.org
）。输出结果可以存储为元数据或缓存，下次加载可直接使用。应允许在播歌过程中根据需要微调节拍（类似 DJ 软件的手动校正）。
渲染协调代理
职责：把波形数据、节拍信息和播放进度组合起来进行渲染协同。例如：在波形上叠加节拍线、循环范围标记、进度指示器等。管理渲染缓存和帧更新，确保与 UI 同步。
调用方式：在波形分析和节拍检测完成后，由上层驱动渲染；在播放过程中，根据计时（Timer）更新滚动位置和播放头。也响应用户缩放/拖拽操作重绘相应部分。
输入：多分辨率波形数据、节拍时间列表、当前播放位置、用户视图参数（缩放比例、循环范围等）。
输出：绘制指令或帧缓存，通常以贴图（texture）或像素数据形式传给 Flutter UI。可以预先生成静态波形图像，然后仅移动光标实现滚动。
预期行为：按 60fps 平滑更新波形滚动和光标位置，确保节拍线与实际音乐同步。可参考 Mixxx 对多个层（波形层、节拍层、循环层、标记层等）的分层渲染优化
mixxx.org
mixxx.org
。
播放控制代理
职责：控制音频硬件输出，包括播放、暂停、停止、快进/快退、跳跃、调整播放速度/音调（变速时保留音高）等功能。维护当前播放状态和进度。
调用方式：Flutter UI 发出指令经桥接代理传入，或由其它系统（如自动播放下一首）触发。
输入：控制命令（播放/暂停/跳转/变速等）。
输出：经音频设备输出播放的音频流；同时周期性输出当前播放时间戳（用于同步 UI）。
预期行为：使用 JUCE 的 AudioTransportSource、AudioFormatReaderSource 等类实现播放流管理和变速变调。播放控制代理应和状态同步模块协同，定时更新播放进度，确保 Flutter 侧进度条或光标随音轨移动而动。
Flutter–JUCE 通信桥代理
职责：承上启下：处理 Flutter 层和本地后端之间的消息传递。常见实现方式是 Flutter 的平台通道（MethodChannel/EventChannel）或 Dart FFI。桥接代理要解析来自 Flutter 的调用（如 loadFile(path)、play()、getWaveformData() 等），分发给对应的本地代理执行；同时，它也应将后端的异步事件（如分析完成、节拍检测结果或播放进度更新）推送给 Flutter 层 UI。
调用方式：作为单例初始化，注册通信通道。Flutter 端发出方法调用时进入本代理；代理内部则调用相应本地功能后通过通道返回结果或事件。
输入：Flutter 端发送的 JSON/参数消息，亦可包括平台回调的系统事件。
输出：调用其他代理的方法或改变状态，将处理结果通过通道返回给 Flutter。
预期行为：应设计清晰的命令接口与数据协议，必要时使用异步回调（Future/事件流）确保 UI 不阻塞。例如，当 Flutter 端请求“加载文件”时，桥接代理调用音频文件管理代理，然后异步返回成功/失败；播放过程中桥接代理可定时通过事件通道发送当前时间戳以更新 UI。
状态同步与生命周期管理
各代理需通过事件总线或观察者模式保持状态同步：例如，新曲目加载后，文件管理代理广播事件以启动波形与节拍分析，分析完成后通知渲染更新。播放控制代理在播放过程中定时发送进度更新，渲染代理和 Flutter UI 接收后更新光标。可以考虑实现一个AgentManager或全局State Agent来注册各子代理，统一调度与销毁。其建议生命周期包括：应用启动时初始化核心代理（桥接、播放、文件管理等），新曲目载入时启动分析代理，曲目切换时清理旧数据。代理之间的数据与状态应尽量解耦，使用消息传递而非直接依赖对象，降低模块耦合。
参考现有 DJ 软件的音频分析方式
为了对标 Mixxx、Serato、Traktor 等专业 DJ 软件的行为，分析其对音频数据的处理策略：
Mixxx：默认对整首曲目进行离线精确分析，包括 BPM 和节拍网格；提供“快速分析”选项仅分析前 1 分钟以加速处理
manual.mixxx.org
。
Serato：提供“分析曲目”功能，将波形概览、节拍网格、自动增益、BPM 等信息计算并缓存到数据库/标签中
support.serato.com
support.serato.com
。分析过程可在后台批量执行，一旦完成曲目即可快速加载。
Traktor：加载曲目时自动启动异步分析（可在首选项开启），生成波形概览（称为“Stripe”）并检测节拍网格
support.native-instruments.com
。用户也可手动在浏览器中对选中曲目触发分析。
这些系统均预分析并缓存结果，避免在混音时出现延迟。推荐架构：在文件管理代理加载新曲目后，即刻异步启动波形与节拍分析（与 Mixxx/Serato/Traktor 类似），完成后将结果缓存。在曲目播放过程中，优先使用已有分析数据进行 UI 渲染；对于仍未分析或需要更高精度的部分，可在后台持续进行实时分析补充。这样可保证：一旦分析完成，即可立即获得完整的波形和节拍信息（无须等到播放过程再计算），提供专业级体验
manual.mixxx.org
support.native-instruments.com
。如果用户中途跳转或调整节奏，实时流处理模块可对剩余部分继续分析，以达到最终精准。
插件化与扩展设计
为便于将来支持多 Deck 或效果模块，应设计可扩展的插件架构：
多 Deck 支持：为每个 Deck 实例化独立的一组代理（文件管理、分析、渲染、播放等），并由一个“Deck 管理器”协调它们（例如选中 Deck 时切换显示和控制）。每个 Deck 代理集可拥有独立的状态和资源，互不冲突。架构应允许动态增加 Deck 实例，例如通过配置或运行时创建新的 Deck 代理集。
效果模块 (Effects)：建议使用 JUCE 的插件架构（AudioProcessor / AudioProcessorGraph），允许加载 VST/AU 或内建 DSP 模块。可以为效果链定义一个 效果代理，管理多个效果处理器的插入顺序和参数控制。效果代理接收音频缓冲区，按链路逐一调用各效果处理器，然后输出给下一节点（如播放代理）。这样新增或替换效果时，只需增加新的插件或修改链路，而不影响整体结构。Mixxx 的效果链功能类似，可导入/导出效果连线
mixxx.org
；本架构应预留可序列化的效果链描述，以便用户保存混合参数。
数据流与示例流程
下图简示了主要代理之间的数据流动关系：
scss
复制
Flutter UI (控件界面)
      ↓  MethodChannel调用
[Bridge 代理]────────────┐
      ↓                │    播放控制命令
[文件管理代理]         │─────────▶[播放控制代理]
      ↓ 触发分析         │    (生成音频流)
[波形分析代理]         │            ↓
      ↓ 数据          └────▶[渲染代理] ──▶ Flutter UI (显示波形+节拍)
[节拍检测代理]         ─────▶▸ 
                      (分析结果缓存)
加载曲目：Flutter 发出 loadFile(path)，Bridge 代理调用文件管理代理加载音频。
分析准备：文件管理代理成功后，触发波形分析代理和节拍检测代理同时运行。两者异步生成波形数据和节拍网格（可见进度）。
渲染准备：波形分析完成后通知渲染代理准备绘制波形；节拍检测完成后通知渲染代理绘制节拍线。渲染代理生成首帧显示图，并通过桥接回传到 Flutter。
播放控制：用户按下播放，Bridge 代理调用播放控制代理，启动音频输出。播放控制代理在音频回调中持续发送当前时间戳给渲染代理。
滚动显示：渲染代理收到时间更新后计算波形滚动偏移和光标位置，继续绘制并更新 Flutter UI 实时画面。节拍同步可通过对比时间戳与节拍列表决定效果（例如对齐波峰时闪烁指示）。
用户交互：如用户快进、调整 BPM/循环等，Bridge 代理向相关代理发出命令并同步更新渲染。
整个架构通过清晰的代理分工和事件通信，实现了类似 Mixxx/Traktor 的分析模式（预分析并缓存波形、节拍），又保持了灵活性以支持未来扩展。
参考资料
JUCE 支持多种音频格式（WAV、AIFF、FLAC、Ogg、MP3 等）
docs.juce.com
docs.juce.com
，macOS/iOS 平台上还可通过 CoreAudioFormat 解码系统内置的 AAC/ALAC 等。
JUCE 的 AudioThumbnail 类可异步扫描音频文件并生成缩略波形，且会缓存结果以加速后续重绘
docs.juce.com
。
Mixxx 2.4 等现代 DJ 软件采用 GPU 加速渲染，可平滑滚动波形并支持 RGB 频段着色
mixxx.org
mixxx.org
。
参考 Mixxx、Serato、Traktor 等软件的曲目预分析功能，建议在加载时异步分析全曲波形和节拍
manual.mixxx.org
support.native-instruments.com
，并将结果缓存以便实时播放时使用。
上述方案和代理划分为工程提供了明确的模块化路径，便于使用 AI 或团队分工开发，同时保证未来功能扩展（多 Deck、特效插件等）时的可插拔性和可维护性。
